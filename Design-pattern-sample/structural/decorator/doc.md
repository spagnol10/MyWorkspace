# Decorator

### Cen√°rio de problemaü™Ü

Imagine que voc√™ tem um sistema de **notifica√ß√µes**. A notifica√ß√£o b√°sica envia mensagens via e-mail. No entanto, voc√™ deseja adicionar a capacidade de enviar mensagens via SMS e registrar as notifica√ß√µes em um log. Usar o **Decorator** permite adicionar essas funcionalidades de forma flex√≠vel e modular.

Modificar diretamente a classe base que possui a funcionalidade pode ser uma m√° ideia, especialmente se v√°rias funcionalidades forem opcionais e n√£o aplic√°veis em todas as situa√ß√µes.

---

### Utiliza√ß√£o do padr√£o‚úÖ

**Decorator** resolve esse problema, permitindo que comportamentos adicionais sejam anexados dinamicamente a um objeto existente sem alterar sua estrutura original.

---

### Exemplo em Java‚òï

```java
//1
interface INotifier {
    void send(String message);
}
```
1. Interface comum para o componente e o decorador

```java
//1
class EmailNotifier implements INotifier {
    @Override
    public void send(String message) {
        System.out.println("Enviando e-mailüì®: " + message);
    }
}
```
1. Componente concreto que implementa o comportamento b√°sico

```java
//1
abstract class NotifierDecorator implements INotifier {
    protected INotifier wrappedNotifier;

    public NotifierDecorator(INotifier INotifier) {
        this.wrappedNotifier = INotifier;
    }

    @Override
    public void send(String message) {
        wrappedNotifier.send(message);
    }
}
```
1. Classe Decorator que adiciona funcionalidades ao INotifier

```java
//1
class SMSNotifierDecorator extends NotifierDecorator {
    public SMSNotifierDecorator(INotifier INotifier) {
        super(INotifier);
    }

    @Override
    public void send(String message) {
        super.send(message);
        sendSMS(message);
    }

    private void sendSMS(String message) {
        System.out.println("Enviando SMSüì≤: " + message);
    }
}
```
1. Decorador concreto que adiciona a funcionalidade de enviar SMS

```java
//1
class LogNotifierDecorator extends NotifierDecorator {
    public LogNotifierDecorator(INotifier INotifier) {
        super(INotifier);
    }

    @Override
    public void send(String message) {
        super.send(message);
        logNotification(message);
    }

    private void logNotification(String message) {
        System.out.println("Registrando notifica√ß√£o: " + message);
    }
}
```
1. Decorador concreto que adiciona a funcionalidade de logar notifica√ß√µes

Aplica√ß√£o do Decorator

```java
public class Application {
    public static void main(String[] args) {
        //1
        INotifier emailNotifier = new EmailNotifier();

        //2
        INotifier smsNotifier = new SMSNotifierDecorator(emailNotifier);

        //3
        INotifier logAndSmsNotifier = new LogNotifierDecorator(smsNotifier);

        //4
        logAndSmsNotifier.send("Ol√°, esse √© um exemplo de notifica√ß√£o!");
    }
}
```
1. Notificador b√°sico
2. Adiciona a funcionalidade de SMS
3. Adiciona a funcionalidade de log, al√©m do SMS
4. Envia a notifica√ß√£o

---

### Explica√ß√£oü§ì

- A interface `INotifier` define o m√©todo `send()`, que todas as classes concretas e decoradores ir√£o implementar.
- A classe `EmailNotifier` √© o **componente concreto**, implementando o envio de notifica√ß√µes via e-mail.
- As classes `SMSNotifierDecorator` e `LogNotifierDecorator` s√£o **decoradores concretos** que adicionam funcionalidades de envio de SMS e registro de logs, respectivamente. Elas utilizam a composi√ß√£o para adicionar novos comportamentos de forma incremental.

---

### Quando utilizar?ü§î

**Decorator** √© √∫til quando:
- Quando voc√™ deseja adicionar responsabilidades ou funcionalidades adicionais a objetos individuais de maneira din√¢mica.
- Quando a extens√£o por heran√ßa n√£o √© vi√°vel ou cria uma complexidade excessiva.
- Quando diferentes combina√ß√µes de funcionalidades devem ser aplicadas a objetos, e criar subclasses para todas as combina√ß√µes seria impratic√°vel.

---

### Utiliza√ß√£o mundo realüåé

- **Java I/O**: Biblioteca Java √© o sistema de classes de Input/Output (I/O). As classes de I/O utilizam Decorators para adicionar funcionalidades como buffering, compress√£o ou criptografia a streams de dados. **Abstra√ß√£o (Componente)**: `InputStream`, `OutputStream`. **Componente Concreto**: `FileInputStream`, `FileOutputStream`. **Decoradores**: `BufferedInputStream`, `DataInputStream`, `GZIPInputStream`.
- **Spring Security**: Adicionar diferentes funcionalidades de seguran√ßa, como autentica√ß√£o, autoriza√ß√£o, e controle de acesso. Isso √© feito por meio de `AuthenticationProvider` e `SecurityContext`, que s√£o decoradores sobre a autentica√ß√£o b√°sica. [Para mais sobre](https://www.momentslog.com/development/design-pattern/exploring-the-decorator-pattern-in-spring-security-adding-custom-security-functionality-to-spring-security-framework).
-  **Servlet API**: Para modificar ou estender a funcionalidade de requisi√ß√µes e respostas HTTP. Isso √© feito por meio de `HttpServletRequestWrapper` e `HttpServletResponseWrapper`, que permitem "decorar" uma requisi√ß√£o ou resposta HTTP com funcionalidades adicionais(cabe√ßalhos extras, manipular par√¢metros, etc).

---

Em resumo, √© ideal em cen√°rios onde a funcionalidade deve ser incrementada de forma flex√≠vel e din√¢mica, como em sistemas de notifica√ß√£o, streams de I/O ou interfaces gr√°ficas.